{
  "manifest": {
    "name": "@microsoft/ts-command-line",
    "version": "4.3.2",
    "description": "An object-oriented command-line parser for TypeScript",
    "repository": {
      "type": "git",
      "url": "https://github.com/microsoft/rushstack/tree/master/libraries/ts-command-line"
    },
    "main": "lib/index.js",
    "typings": "dist/ts-command-line.d.ts",
    "scripts": {
      "build": "gulp test --clean"
    },
    "license": "MIT",
    "dependencies": {
      "@types/argparse": "1.0.33",
      "argparse": "~1.0.9",
      "colors": "~1.2.1"
    },
    "devDependencies": {
      "@types/jest": "23.3.11",
      "@types/node": "8.10.54",
      "gulp": "~4.0.2",
      "@microsoft/node-library-build": "6.1.2",
      "@microsoft/rush-stack-compiler-3.4": "0.1.15"
    },
    "_registry": "npm",
    "_loc": "C:\\Users\\SriharshaShesham\\AppData\\Local\\Yarn\\Cache\\v6\\npm-@microsoft-ts-command-line-4.3.2-87341de2e24f279259297ebd38530300a9f97bc3-integrity\\node_modules\\@microsoft\\ts-command-line\\package.json",
    "readmeFilename": "README.md",
    "readme": "# ts-command-line\n\nThis library helps you create professional command-line tools for Node.js. By \"professional\", we mean:\n\n- **no gotchas for users**:  Seems obvious, but try typing \"`npm install --save-dex`\" instead of \"`npm install --save-dev`\" sometime.  The command seems to execute successfully, but it doesn't save anything! The misspelled flag was silently ignored.  This lack of rigor plagues many familiar NodeJS tools and can be confusing and frustrating.  For a great user experience, a command line tool should always be strict about its syntax.\n\n- **no gotchas for developers**:  Many command-line libraries store their parsed data in a simple JavaScript hash object.  This is convenient for small projects. But suppose a large project has many different source files that define and read parameters. If you try to read `data['output-dir']` when it wasn't defined, or if you misspell the key name, your tool will silently behave as if the parameter was omitted.  And is `data['max-count']` a string or a number? Hard to tell! We solve this by modeling each parameter kind as a real TypeScript class.\n\n- **automatic documentation**: Some command-line libraries treat the `--help` docs as someone else's job.  **ts-command-line** requires each every parameter to have a documentation string, and will automatically generate the `--help` docs for you.  If you like to write long paragraphs, no problem -- they will be word-wrapped correctly.   *[golf clap]*\n\n- **structure and extensibility**: Instead of a simple function chain, **ts-command-line** provides a  \"scaffold\" pattern that makes it easy to find and understand the command-line implementation for any tool project.  The scaffold model is generally recommended, but there's also a \"dynamic\" model if you need it.  See below for examples.\n\nInternally, the implementation is based on [argparse](https://www.npmjs.com/package/argparse) and the Python approach to command-lines.  Compared to other libraries, **ts-command-line** doesn't provide zillions of custom syntaxes and bells and whistles.  Instead it aims to be a simple, consistent, and professional solution for your command-line tool.  Give it a try!\n\n\n### Some Terminology\n\nSuppose that we want to parse a command-line like this:\n\n```\nwidget --verbose push --force --max-count 123\n```\n\nIn this example, we can identify the following components:\n\n- The **tool name** in this example is `widget`.  This is the name of your Node.js bin script.\n- The **parameters** are  `--verbose`, `--force`, and `--max-count`.\n- The currently supported **parameter kinds** include: **flag** (i.e. boolean), **integer**, **string**, **choice** (i.e. enums), and **string list**.\n- The value \"123\" is the **argument** for the `--max-count` integer parameter.  (Flags don't have arguments, because their value is determined by whether the flag was provided or not.)\n- Similar to Git's command-line, the `push` token is called an **action**.  It acts as sub-command with its own unique set of parameters.\n- The `--verbose` flag is a **global parameter** because it precedes the action name.  It affects all actions.\n- The `--force` flag is an **action parameter** because it comes after the action name.  It only applies to that action.\n\n\n## Scaffold Model\n\nIf your tool uses the scaffold model, you will create subclasses of two abstract base classes:  `CommandLineParser` for the overall command-line, and `CommandLineAction` for each action.\n\nContinuing our example from above, suppose we want to start with a couple simple flags like this:\n\n```\nwidget --verbose push --force\n```\n\nWe could define our subclass for the \"`push`\" action like this:\n\n```typescript\nclass PushAction extends CommandLineAction {\n  private _force: CommandLineFlagParameter;\n\n  public constructor() {\n    super({\n      actionName: 'push',\n      summary: 'Pushes a widget to the service',\n      documentation: 'Your long description goes here.'\n    });\n  }\n\n  protected onExecute(): Promise<void> { // abstract\n    return BusinessLogic.doTheWork(this._force.value);\n  }\n\n  protected onDefineParameters(): void { // abstract\n    this._force = this.defineFlagParameter({\n      parameterLongName: '--force',\n      parameterShortName: '-f',\n      description: 'Push and overwrite any existing state'\n    });\n  }\n}\n```\n\nThen we might define the parser subclass like this:\n\n```typescript\nclass WidgetCommandLine extends CommandLineParser {\n  private _verbose: CommandLineFlagParameter;\n\n  public constructor() {\n    super({\n      toolFilename: 'widget',\n      toolDescription: 'The widget tool is really great.'\n    });\n\n    this.addAction(new PushAction());\n  }\n\n  protected onDefineParameters(): void { // abstract\n    this._verbose = this.defineFlagParameter({\n      parameterLongName: '--verbose',\n      parameterShortName: '-v',\n      description: 'Show extra logging detail'\n    });\n  }\n\n  protected onExecute(): Promise<void> { // override\n    BusinessLogic.configureLogger(this._verbose.value);\n    return super.onExecute();\n  }\n}\n```\n\nTo invoke the parser, the application entry point will do something like this:\n\n```typescript\nconst commandLine: WidgetCommandLine = new WidgetCommandLine();\ncommandLine.execute();\n```\n\nWhen we run `widget --verbose push --force`, the `PushAction.onExecute()` method will get invoked and then your business logic takes over.\n\n\n#### Testing out the docs\n\nIf you invoke the tool as \"`widget --help`\", the docs are automatically generated:\n\n```\nusage: widget [-h] [-v] <command> ...\n\nThe widget tool is really great.\n\nPositional arguments:\n  <command>\n    push         Pushes a widget to the service\n\nOptional arguments:\n  -h, --help     Show this help message and exit.\n  -v, --verbose  Show extra logging detail\n\nFor detailed help about a specific command, use: widget <command> -h\n```\n\nFor help about the `push` action, the user can type \"`widget push --help`\", which shows this output:\n\n```\nusage: widget push [-h] [-f]\n\nYour long description goes here.\n\nOptional arguments:\n  -h, --help   Show this help message and exit.\n  -f, --force  Push and overwrite any existing state\n```\n\n## Dynamic Model\n\nThe action subclasses provide a simple, recognizable pattern that you can use across all your tooling projects. It's the generally recommended approach. However, there are some cases where we need to break out of the scaffold.  For example:\n\n- Actions or parameters may be discovered at runtime, e.g. from a config file\n- The actions and their implementations may sometimes have very different structures\n\nIn this case, you can use the `DynamicCommandLineAction` and `DynamicCommandLineParser`  classes which are not abstract (and not intended to be subclassed).  Here's our above example rewritten for this model:\n\n```typescript\n// Define the parser\nconst commandLineParser: DynamicCommandLineParser = new DynamicCommandLineParser({\n  toolFilename: 'widget',\n  toolDescription: 'The widget tool is really great.'\n});\ncommandLineParser.defineFlagParameter({\n  parameterLongName: '--verbose',\n  parameterShortName: '-v',\n  description: 'Show extra logging detail'\n});\n\n// Define the action\nconst action: DynamicCommandLineAction = new DynamicCommandLineAction({\n  actionName: 'push',\n  summary: 'Pushes a widget to the service',\n  documentation: 'More detail about the \"push\" action'\n});\ncommandLineParser.addAction(action);\n\naction.defineFlagParameter({\n  parameterLongName: '--force',\n  parameterShortName: '-f',\n  description: 'Push and overwrite any existing state'\n});\n\n// Parse the command line\ncommandLineParser.execute(process.argv).then(() => {\n  console.log('The action is: ' + commandLineParser.selectedAction!.actionName);\n  console.log('The force flag is: ' + action.getFlagParameter('--force').value);\n});\n```\n\nYou can also mix the two models.  For example, we could augment the `WidgetCommandLine` from the original model by adding `DynamicAction` objects to it.\n\n\n### Further reading\n\nThe [API reference](https://rushstack.io/pages/api/ts-command-line/) has\ncomplete documentation for the library.\n\nHere are some real world GitHub projects that illustrate different use cases for **ts-command-line**:\n\n- [@microsoft/rush](https://www.npmjs.com/package/@microsoft/rush)\n- [@microsoft/api-extractor](https://www.npmjs.com/package/@microsoft/api-extractor)\n- [@microsoft/api-documenter](https://www.npmjs.com/package/@microsoft/api-documenter)\n",
    "licenseText": "@microsoft/ts-command-line\n\nCopyright (c) Microsoft Corporation. All rights reserved.\n\nMIT License\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/@microsoft/ts-command-line/-/ts-command-line-4.3.2.tgz#87341de2e24f279259297ebd38530300a9f97bc3",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/@microsoft/ts-command-line/-/ts-command-line-4.3.2.tgz",
    "hash": "87341de2e24f279259297ebd38530300a9f97bc3",
    "integrity": "sha512-2QeyilabCe6IpBylPXuY6dCA1S9ym3Ii0zakXVPpyfjSj1NesnyuUeuh6e8kyIqzqJ+3LYjfPG63XzUBtwGqqw==",
    "registry": "npm",
    "packageName": "@microsoft/ts-command-line",
    "cacheIntegrity": "sha512-2QeyilabCe6IpBylPXuY6dCA1S9ym3Ii0zakXVPpyfjSj1NesnyuUeuh6e8kyIqzqJ+3LYjfPG63XzUBtwGqqw== sha1-hzQd4uJPJ5JZKX69OFMDAKn5e8M="
  },
  "registry": "npm",
  "hash": "87341de2e24f279259297ebd38530300a9f97bc3"
}