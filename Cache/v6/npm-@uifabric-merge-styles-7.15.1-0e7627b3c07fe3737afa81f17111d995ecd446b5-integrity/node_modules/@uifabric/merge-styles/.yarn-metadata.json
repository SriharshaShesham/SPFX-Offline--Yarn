{
  "manifest": {
    "name": "@uifabric/merge-styles",
    "version": "7.15.1",
    "description": "Style loading utilities.",
    "main": "lib-commonjs/index.js",
    "module": "lib/index.js",
    "sideEffects": [
      "lib/version.js"
    ],
    "typings": "lib/index.d.ts",
    "repository": {
      "type": "git",
      "url": "https://github.com/microsoft/fluentui"
    },
    "license": "MIT",
    "scripts": {
      "build": "just-scripts build",
      "bundle": "just-scripts bundle",
      "lint": "just-scripts lint",
      "test": "just-scripts test",
      "just": "just-scripts",
      "clean": "just-scripts clean",
      "code-style": "just-scripts code-style",
      "start-test": "just-scripts jest-watch",
      "update-api": "just-scripts update-api"
    },
    "devDependencies": {
      "@types/jest": "~24.9.0",
      "@uifabric/tslint-rules": "^7.2.2",
      "@uifabric/build": "^7.0.0"
    },
    "dependencies": {
      "@uifabric/set-version": "^7.0.15",
      "tslib": "^1.10.0"
    },
    "_registry": "npm",
    "_loc": "C:\\Users\\SriharshaShesham\\AppData\\Local\\Yarn\\Cache\\v6\\npm-@uifabric-merge-styles-7.15.1-0e7627b3c07fe3737afa81f17111d995ecd446b5-integrity\\node_modules\\@uifabric\\merge-styles\\package.json",
    "readmeFilename": "README.md",
    "readme": "# @uifabric/merge-styles\n\nThe `merge-styles` library provides utilities for loading styles through javascript. It is designed to make it simple to style components through javascript. It generates css classes, rather than using inline styling, to ensure we can use css features like pseudo selectors (:hover) and parent/child selectors (media queries).\n\nThe library was built for speed and size; the entire package is 2.62k gzipped. It has no dependencies other than `tslib`.\n\nSimple usage:\n\n```\nimport { mergeStyles, mergeStyleSets } from '@uifabric/merge-styles';\n\n// Produces 'css-0' class name which can be used anywhere\nmergeStyles({ background: 'red' });\n\n// Produces a class map for a bunch of rules all at once\nmergeStyleSets({\n  root: { background: 'red' },\n  child: { background: 'green' }\n});\n\n// Returns { root: 'root-0', child: 'child-1' }\n```\n\nBoth utilities behave similar to a deep Object.assign; you can collapse many objects down into one class name or class map.\n\nThe basic idea is to provide tools which can take in one or more css styling objects representing the styles for a given element, and return a single class name. If the same set of styling is passed in, the same name returns and nothing is re-registered.\n\n## Motivation\n\nDefining rules at runtime has a number of benefits over traditional build time staticly produced css:\n\n- Only register classes that are needed, when they're needed, reducing the overall selector count and improving TTG.\n\n- Dynamically create new class permutations based on contextual theming requirements. (Use a different theme inside of a DIV without downloading multiple copies of the css rule definitions.)\n\n- Use JavaScript to define the class content (using utilities like color converters, or reusing constant numbers becomes possible.)\n\n- Allow control libraries to merge customized styling in with their rules, avoiding complexities like css selector specificity.\n\n- Simplify RTL processing; lefts become rights in RTL, in the actual rules. No complexity like `html[dir=rtl]` prefixes necessary, which alleviates unexpected specificity bugs. (You can use `/* noflip */` comments to avoid flipping if needed.)\n\n- Reduce bundle size. Automatically handles vendor prefixing, unit providing, RTL flipping, and margin/padding expansion (e.g. margin will automatically expand out to margin TRBL, so that we avoid specificity problems when merging things together.)\n\n- Reduce the build time overhead of running through CSS preprocessors.\n\n- TypeScript type safety; spell \"background\" wrong and get build breaks.\n\n## What tradeoffs are there? Are there downsides to using JavaScript to process styling?\n\nIn static solutions, there is very little runtime evaluation required; everything is injected as-is. Things like auto prefixing and language specific processing like sass mixins are all evaluated at build time.\n\nIn runtime styling, much of this is evaluated in the browser, so you are paying a cost in doing this. However, with performance optimizations like memoization, you can minimize this quite a bit, and you gain all of the robustness enumerated above.\n\n# API\n\nThe api surfaces consists of 3 methods and a handful of interfaces:\n\n`mergeStyles(..args[]: IStyle[]): string` - Takes in one or more style objects, merges them in the right order, and produces a single css class name which can be injected into any component.\n\n`mergeStyleSets(...args[]: IStyleSet[]): { [key: string]: string }` - Takes in one or more style set objects, each consisting of a set of areas, each which will produce a class name. Using this is analogous to calling mergeStyles for each property in the object, but ensures we maintain the set ordering when multiple style sets are merged.\n\n`concatStyleSets(...args[]: IStyleSet[]): IStyleSet` - In some cases you simply need to combine style sets, without actually generating class names (it is costs in performance to generate class names.) This tool returns a single set merging many together.\n\n`concatStyleSetsWithProps(props: {}, ...args[]: IStyleSet[]): IStyleSet` - Similar to `concatStyleSet` except that style sets which contain functional evaluation of styles are evaluated prior to concatenating.\n\nExample:\n\n```tsx\nconst result = concatStyleSetsWithProps<IFooProps, IFooStyles>(\n  { foo: 'bar' },\n  (props: IFooProps) => ({ root: { background: props.foo } }),\n  (props: IFooProps) => ({ root: { color: props.foo } }),\n);\n```\n\n## Vocabulary\n\nA **style object** represents the collection of css rules, except that the names are camelCased rather than kebab-cased. Example:\n\n```tsx\nlet style = {\n  backgroundColor: 'red',\n  left: 42,\n};\n```\n\nAdditionally, **style objects** can contain selectors under the `selectors` property:\n\n```tsx\nlet style = {\n  backgroundColor: 'red',\n  selectors: {\n    ':hover': {\n      backgroundColor: 'blue';\n    },\n    '.parent &': { /* parent selector */ },\n    '& .child': { /* child selector */ }\n  }\n};\n```\n\nA **style set** represents a map of area to style object. When building a component, you need to generate a class name for each element that requires styling. You would define this in a **style set**.\n\n```tsx\nlet styleSet = {\n  root: { background: 'red' },\n  button: { margin: 42 },\n};\n```\n\n## Basic usage\n\nWhen building a component, you will need a **style set** map of class names to inject into your elements' class attributes.\n\nThe recommended pattern is to provide the classnames in a separate function, typically in a separate file `ComponentName.classNames.ts`.\n\n```tsx\nimport { IStyle, mergeStyleSets } from '@uifabric/merge-styles';\n\nexport interface IComponentClassNames {\n  root: string;\n  button: string;\n  buttonIcon: string;\n}\n\nexport const getClassNames = (): IComponentClassNames => {\n  return mergeStyleSets({\n    root: {\n      background: 'red',\n    },\n\n    button: {\n      backgroundColor: 'green',\n    },\n\n    buttonIcon: {\n      margin: 10,\n    },\n  });\n};\n```\n\nThe class map can then be used in a component:\n\n```tsx\nimport { getClassNames } from './MyComponent.classNames';\n\nexport const MyComponent = () => {\n  let { root, button, buttonIcon } = getClassNames();\n\n  return (\n    <div className={root}>\n      <button className={button}>\n        <i className={buttonIcon} />\n      </button>\n    </div>\n  );\n};\n```\n\n## Selectors\n\n### Basic pseudo-selectors (:hover, :active, etc)\n\nCustom selectors can be defined within `IStyle` definitions under the `selectors` section:\n\n```tsx\n{\n  background: 'red',\n  selectors: {\n    ':hover': {\n      background: 'green'\n    }\n  }\n}\n```\n\nBy default, the rule will be appended to the current selector scope. That is, in the above scenario, there will be 2 rules inserted when using `mergeStyles`:\n\n```css\n.css-0 {\n  background: red;\n}\n.css-0:hover {\n  background: green;\n}\n```\n\n### Parent/child selectors\n\nIn some cases, you may need to use parent or child selectors. To do so, you can define a selector from scratch and use the `&` character to represent the generated class name. When using the `&`, the current scope is ignored. Example:\n\n```tsx\n{\n  selectors: {\n    // selector relative to parent\n    '.ms-Fabric--isFocusVisible &': {\n      background: 'red'\n    }\n    // selector for child\n    '& .child' {\n      background: 'green'\n    }\n  }\n}\n```\n\nThis would register the rules:\n\n```css\n.ms-Fabric--isFocusVisible .css-0 {\n  background: red;\n}\n.css-0 .child {\n  background: green;\n}\n```\n\n### Global selectors\n\nWhile we suggest avoiding global selectors, there are some cases which make sense to register things globally. Keep in mind that global selectors can't be guaranteed unique and may suffer from specificity problems and versioning issues in the case that two different versions of your library get rendered on the page.\n\nTo register a selector globally, wrap it in a `:global()` wrapper:\n\n```tsx\n{\n  selectors: {\n    ':global(button)': {\n      overflow: 'visible'\n    }\n  }\n}\n```\n\n### Media and feature queries\n\nMedia queries can be applied via selectors. For example, this style will produce a class which has a red background when above 600px, and green when at or below 600px:\n\n```tsx\nmergeStyles({\n  background: 'red',\n  selectors: {\n    '@media(max-width: 600px)': {\n      background: 'green',\n    },\n    '@supports(display: grid)': {\n      display: 'grid',\n    },\n  },\n});\n```\n\nProduces:\n\n```css\n.css-0 {\n  background: red;\n}\n\n@media (max-width: 600px) {\n  .css-0 {\n    background: green;\n  }\n}\n\n@supports (display: grid) {\n  .css-0 {\n    display: grid;\n  }\n}\n```\n\n### Referencing child elements within the mergeStyleSets scope\n\nOne important concept about `mergeStyleSets` is that it produces a map of class names for the given elements:\n\n```tsx\nmergeStyleSets({\n  root: { background: 'red' }\n  thumb: { background: 'green' }\n});\n```\n\nProduces:\n\n```css\n.root-0 {\n  background: red;\n}\n.thumb-1 {\n  background: green;\n}\n```\n\nIn some cases, you may need to alter a child area by interacting with the parent. For example, when the parent is hovered, change the child background. We recommend using global, non-changing static classnames\nto target the parent elements:\n\n```tsx\nconst classNames = {\n  root: 'Foo-root',\n  child: 'Foo-child',\n};\n\nmergeStyleSets({\n  root: [classNames.root, { background: 'lightgreen' }],\n\n  child: [\n    classNames.child,\n    {\n      selectors: {\n        [`.${classNames.root}:hover &`]: {\n          background: 'green',\n        },\n      },\n    },\n  ],\n});\n```\n\nThe important part here is that the selector does not have any mutable information. In the example above,\nif `classNames.root` were dynamic, it would require the rule to be re-registered when it mutates, which\nwould be a performance hit.\n\n## Custom class names\n\nBy default when using `mergeStyles`, class names that are generated will use the prefix `css-` followed by a number, creating unique rules where needed. For example, the first class name produced will be 'css-0'.\n\nWhen using `mergeStyleSets`, class names automatically use the area name as the prefix.\n\nMerging rules like:\n\n```ts\nmergeStyleSets({ a: { ... }, b: { ... } })\n```\n\nWill produce the class name map:\n\n```ts\n{ a: 'a-0', b: 'b-1' }\n```\n\nIf you'd like to override the default prefix in either case, you can pass in a `displayName` to resolve this:\n\n```tsx\n{\n  displayName: 'MyComponent',\n  background: 'red'\n}\n```\n\nThis generates:\n\n```css\n.MyComponent-0 {\n  background: red;\n}\n```\n\n## Managing conditionals and states\n\nStyle objects can be represented by a simple object, but also can be an array of the objects. The merge functions will handle arrays and merge things together in the given order. They will also ignore falsey values, allowing you to conditionalize the results.\n\nIn the following example, the root class generated will be different depending on the `isToggled` state:\n\n```tsx\nexport const getClassNames = (isToggled: boolean): IComponentClassNames => {\n  return mergeStyleSets({\n    root: [\n      {\n        background: 'red',\n      },\n      isToggled && {\n        background: 'green',\n      },\n    ],\n  });\n};\n```\n\n## RTL support\n\nBy default, nearly all of the major rtl-sensitive CSS properties will be auto flipped when the dir=\"rtl\" flag is present on the `HTML` tag of the page.\n\nThere are some rare scenarios (linear-gradients, etc) which are not flipped, for the sake of keeping the bundle size to a minimum. If there are missing edge cases, please submit a PR to address.\n\nIn rare condition where you want to avoid auto flipping, you can annotate the rule with the `@noflip` directive:\n\n```tsx\nmergeStyles({\n  left: '42px @noflip',\n});\n```\n\n## Optimizing for performance\n\nResolving the class names on every render can be an unwanted expense especially in hot spots where things are rendered frequently. To optimize, we recommend 2 guidelines:\n\n1. For your `getClassNames` function, flatten all input parameters into simple immutable values. This helps the `memoizeFunction` utility to cache the results based on the input.\n\n2. Use the `memoizeFunction` function from the `@uifabric/utilities` package to cache the results, given a unique combination of inputs. Example:\n\n```tsx\nimport { memoizeFunction } from '@uifabric/utilities';\n\nexport const getClassNames = memoizeFunction((isToggled: boolean) => {\n  return mergeStyleSets({\n    // ...\n  });\n});\n```\n\n## Registering fonts\n\nRegistering font faces example:\n\n```tsx\nimport { fontFace } from '@uifabric/merge-styles';\n\nfontFace({\n  fontFamily: `\"Segoe UI\"`,\n  src: `url(\"//cdn.com/fontface.woff2) format(woff2)`,\n  fontWeight: 'normal',\n});\n```\n\nNote that in cases like `fontFamily` you may need to embed quotes in the string as shown above.\n\n## Registering keyframes\n\nRegistering animation keyframes example:\n\n```tsx\nimport { keyframes, mergeStyleSets } from '@uifabric/merge-styles';\n\nlet fadeIn = keyframes({\n  from: {\n    opacity: 0,\n  },\n  to: {\n    opacity: 1,\n  },\n});\n\nexport const getClassNames = () => {\n  return mergeStyleSets({\n    root: {\n      animationName: fadeIn,\n    },\n  });\n};\n```\n\n## Controlling where styles are injected\n\nBy default `merge-styles` will initially inject a `style` element into the document head as the first node and then append and new `style` elements as next sibling to the previous one added.\n\nIn some cases you may want to control where styles are injected to ensure some stylesheets are more specific than others. To do this, you can add a placeholder `style` element in the head with `data-merge-styles` attribute:\n\n```html\n<head>\n  <style data-merge-styles></style>\n</head>\n```\n\nMerge styles will ensure that any generated styles are added after the placeholder.\n\n## Server-side rendering\n\nYou can import `renderStatic` method from the `/lib/server` entry to render content and extract the css rules that would have been registered, as a string.\n\nExample:\n\n```tsx\nimport { renderStatic } from '@uifabric/merge-styles/lib/server';\n\nlet { html, css } = renderStatic(() => {\n  return ReactDOM.renderToString(...);\n});\n```\n\nCaveats for server-side rendering:\n\n- Rules registered in the file scope of code won't be re-evaluated and therefore won't be included in the result. Try to avoid using classes which are not evaluated at runtime.\n\nFor example:\n\n```tsx\nconst rootClass = mergeStyles({ background: 'red' });\nconst App = () => <div className={rootClass} />;\n\n// App will render, but \"rootClass\" is a string which won't get re-evaluated in this call.\nrenderStatic(() => ReactDOM.renderToString(<App/>);\n```\n\n- Using `memoizeFunction` around rule calculation can help with excessive rule recalc performance overhead.\n\n- Rehydration on the client may result in mismatched rules. You can apply a namespace on the server side to ensure there aren't name collisions.\n\n## Working with content security policy (CSP)\n\nSome content security policies prevent style injection without a nonce. To set the nonce used by `merge-styles`:\n\n```ts\nStylesheet.getInstance().setConfig({\n  cspSettings: { nonce: 'your nonce here' },\n});\n```\n\nIf you're working inside a Fluent UI React app ([formerly Office UI Fabric React](https://developer.microsoft.com/en-us/office/blogs/ui-fabric-is-evolving-into-fluent-ui/)), this setting can also be applied using the global `window.FabricConfig.mergeStyles.cspSettings`. Note that this must be set before any Fluent UI React code is loaded, or it may not be applied properly.\n\n```ts\nwindow.FabricConfig = {\n  mergeStyles: {\n    cspSettings: { nonce: 'your nonce here' },\n  },\n};\n```\n",
    "licenseText": "Fluent UI React - merge-styles\n\nCopyright (c) Microsoft Corporation\n\nAll rights reserved.\n\nMIT License\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"\"Software\"\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nNote: Usage of the fonts and icons referenced in Fluent UI React is subject to the terms listed at https://aka.ms/fluentui-assets-license\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/@uifabric/merge-styles/-/merge-styles-7.15.1.tgz#0e7627b3c07fe3737afa81f17111d995ecd446b5",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/@uifabric/merge-styles/-/merge-styles-7.15.1.tgz",
    "hash": "0e7627b3c07fe3737afa81f17111d995ecd446b5",
    "integrity": "sha512-fkOsn9Ovbe+7BGsaz2zXnl1fEAInrMG8fQxjRuu9YXwXmzd9u8BzQvy/Mf1sNOZIbTLFYewwm2Swv2zlc1NRcg==",
    "registry": "npm",
    "packageName": "@uifabric/merge-styles",
    "cacheIntegrity": "sha512-fkOsn9Ovbe+7BGsaz2zXnl1fEAInrMG8fQxjRuu9YXwXmzd9u8BzQvy/Mf1sNOZIbTLFYewwm2Swv2zlc1NRcg== sha1-DnYns8B/43N6+oHxcRHZlezURrU="
  },
  "registry": "npm",
  "hash": "0e7627b3c07fe3737afa81f17111d995ecd446b5"
}